/*
 * Source usage tracking log
 * TCNJ
 * Brian Bernas
 * bernasb@tcnj.edu
 * brianbernas@gmail.com
 *
 */

/*********************************
 * Writes a Log in the following format
 * ------------------------------------
 * SOURCE_NAME, PRESS_COUNT[28], TIME[hh:mm]
 *********************************
 */

#SYMBOL_NAME "TCNJ Usage Tracking"

#CATEGORY "46" "TCNJ" // Custom

#ENABLE_TRACE

#DEFINE_CONSTANT	SOURCES		16
#DEFINE_CONSTANT	MAXLENGTH	2048


// Data Structures
Structure SourceStruct
{
	String			Name[24];
	Integer			PressCount;
    Long_Integer	Usage;
};

// IO
Digital_Input		Enable_Tracking,	// Run the logging timer
					_skip_,
					Clear_Log,			// Clear the log on disk
					Load_Log,			// Reload the log file from disk
					Save_Log,			// Save log to disk
					_skip_;

Digital_Input		Source_Active_Fb[SOURCES],
					_skip_;

String_Input		Source_Name[SOURCES][24];

Analog_Output		_skip_,
					_skip_,
					_skip_,
					_skip_,
					_skip_,
					_skip_,
					_skip_,
					Source_Press_Count[SOURCES];

String_Output		_skip_,
					Source_Usage_Time[SOURCES];

String_Parameter	Log_Filename[48];

// Variables
Integer				ActiveSource;			// Current active source index
Long_Integer		TrackTimeStart;			// Start time for last tracking event
String				Full_Log[MAXLENGTH];
SourceStruct		AllSources[SOURCES];	// Array of all sources and tracking status

// Functions
Function Rebuild_Log()
{
	Integer i;
	String tmplog[MAXLENGTH];
	String tmpsrc[64];
    
	// Start with a blank temp log
	tmplog = "";

	// Iterate through each source and add it to the list if there is a source name
	for (i = 1 to SOURCES) {
		if (len(AllSources[i].Name) > 1) {
			MakeString(tmpsrc, "%s, %u, %lu\x0D", AllSources[i].Name, AllSources[i].PressCount, AllSources[i].Usage);

			tmplog = tmplog + tmpsrc;
		}
	}

	// If the tmplog contains data, copy it to the Full_Log
	if (len(tmplog) > 3) {
		Full_Log = tmplog;
	}
}

Function Parse_Source_Log(String source_string)
{
	// Variables for the following...
	// length of the source string, current string position, find string position,
	// The index of the matching source when found, `for` iteration
	// Name of the source in the source_string
	Integer strlen, cpos, fpos, found_source, i;
	String found_name[24];
	
	// Length of the whole source log
	// Source logs are like this 'source name, push_count, usage_hours\x0D'
	strlen = len(source_string);
    
	// If the string is too short to contain data, don't waste time
	if (strlen < 4) {
		return;
	}
    
	// Starting position of the string parse
	cpos = 1;
    
	// Find the first comma ','
	fpos = find(",", source_string, cpos);
    
	// If found, the first item is the name, otherwise, no useful data
	if (fpos) {
		found_name = mid(source_string, cpos, fpos-cpos);		
	} else {
		return;
	}

	// Find the matching source in the AllSources array
	found_source = 0;
	for (i = 1 to SOURCES) {
		if (!CompareStringsNoCase(found_name, AllSources[i].Name)) {
			found_source = i;
			break;
		}		
	}
    
	// If no match found, move on
	if (!found_source) {
		return;
	}
    
	// Set the current parsing position to one character after the ','
	cpos = fpos + 1;

	// Find the next comma ','
	fpos = find(",", source_string, cpos);
    
	// Set the presscount
	AllSources[found_source].PressCount = atoi(mid(source_string, cpos, fpos - cpos));

	cpos = fpos + 1;
    
	// Set usage hours
	AllSources[found_source].Usage = atol(mid(source_string, cpos, (strlen - cpos) - 1));			
}

Function Parse_Log_File()
{
	Integer i, cpos, fpos;
	Integer loglen; // Length of the full log text
	String cursourcelog[50];

	loglen = len(Full_Log);
    
	// If the log isn't at least one line long, quit
	if (loglen < 4) {
		return;
	}

	cpos = 1; // Starting parsing position

	for (i = 1 to SOURCES) {
		// Find line breaks
		fpos = find("\x0D", Full_Log, cpos);

		cursourcelog = mid(Full_Log, cpos, (fpos-cpos));

		Parse_Source_Log(cursourcelog);
		cpos = fpos + 1;

		if (cpos >= loglen) {
			i = SOURCES;
		}
	}		
}

Function Load_Log_File()
{
	Signed_Integer nFileHandle; // Open file reference

	StartFileOperations();

	nFileHandle = FileOpen(Log_Filename, _O_RDONLY | _O_TEXT);

	// Check if the file exists
	if (nFileHandle >= 0) {
		ClearBuffer(Full_Log); // Clear any existing logs
		FileRead(nFileHandle, Full_Log, MAXLENGTH); // Load the text into the log

		// Attempt to close the file
		if (FileClose(nFileHandle) <> 0) {
			trace("Error closing source log file.");
		}
	} else {
		trace("Source log file error: %d", nFileHandle);
	}

	EndFileOperations();

	Parse_Log_File();
}

Function Save_Log_File()
{
	Signed_Integer nFileHandle;

	Rebuild_Log();

	StartFileOperations();

	// Open the file for writing in text mode
	// If it doesn't exist, create it
	nFileHandle = FileOpen(Log_Filename, _O_WRONLY | _O_CREAT | _O_TEXT);

	// If the file opened successfully, write the log
	if (nFileHandle >= 0) {
		if (FileWrite(nFileHandle, Full_Log, MAXLENGTH) > 0) {
			trace("Source log written successfully.");
		}

		// Attempt to close the file
		if (FileClose(nFileHandle) <> 0) {
			trace("Error closing source log file.");
		}
	}

	EndFileOperations();
}

Push Enable_Tracking
{
}

Release Enable_Tracking
{
	// Clear the active source
	ActiveSource = 0;
	TrackTimeStart = 0;
}

Push Source_Active_Fb
{
	Integer i, hour, minutes;
	Long_Integer marker;

	i = GetLastModifiedArrayIndex();

	// If tracking is enabled, increment the press count by one
	// and add the timer
	if (Enable_Tracking) {
		// Calculate current time marker
		hour = GetHourNum();
		minutes = GetMinutesNum();
        marker = ((hour*60)+minutes);
		
		// Current marker should always be greater than the start time
		// If not, then don't long this time
		if (TrackTimeStart > marker) {
			TrackTimeStart = marker;
		}
			
		// Increment button press count
		AllSources[i].PressCount = AllSources[i].PressCount + 1;
		Source_Press_Count[i] = AllSources[i].PressCount;
		
		// If there is a tracking time, add the difference to the usage log
		if (TrackTimeStart) {
			AllSources[i].Usage = AllSources[i].Usage + (marker - TrackTimeStart); 
		}
        
		// Set the active source to the new selection
		ActiveSource = i;
        
		// Set the new tracking time marker
		TrackTimeStart = marker;
	}
}

Threadsafe Change Source_Name
{
	Integer i;

	i = GetLastModifiedArrayIndex();

	// Set the source name
	AllSources[i].Name = Source_Name[i];

	// Clear the usage stats
	AllSources[i].PressCount = 0;
	AllSources[i].Usage = 0;
}

Push Save_Log
{
	Save_Log_File();
}

Push Load_Log
{
	Load_Log_File();
}

Push Clear_Log
{
	Integer i;

	ClearBuffer(Full_Log);
    
	// Clear the usage stats
	for (i = 1 to SOURCES) {
		AllSources[i].PressCount = 0;
		AllSources[i].Usage = 0;
	}
}

Function main()
{
	WaitForInitializationComplete();
	Full_Log = "\x0D";	// Start with a clear log
	ActiveSource = 0;
	TrackTimeStart = 0;
}
				